/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201601121427.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: Software Loading Manager interfaace
 */
#ifndef V1_ORG_GENIVI_SOFTWARE_LOADING_MANAGER_HPP_
#define V1_ORG_GENIVI_SOFTWARE_LOADING_MANAGER_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace genivi {

class SoftwareLoadingManager {
public:
    virtual ~SoftwareLoadingManager() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct SWMResult : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SWM_RES_OK = 0,
            SWM_RES_ALREADY_PROCESSED = 1,
            SWM_RES_DEPENDENCY_FAILURE = 2,
            SWM_RES_VALIDATION_FAILED = 3,
            SWM_RES_INSTALL_FAILED = 4,
            SWM_RES_UPGRADE_FAILED = 5,
            SWM_RES_REMOVAL_FAILED = 6,
            SWM_RES_FLASH_FAILED = 7,
            SWM_RES_CREATE_PARTITION_FAILED = 8,
            SWM_RES_DELETE_PARTITION_FAILED = 9,
            SWM_RES_RESIZE_PARTITION_FAILED = 10,
            SWM_RES_WRITE_PARTITION_FAILED = 11,
            SWM_RES_PATCH_PARTITION_FAILED = 12,
            SWM_RES_USER_DECLINED = 13,
            SWM_RES_SOFTWARE_BLACKLISTED = 14,
            SWM_RES_DISK_FULL = 15,
            SWM_RES_NOT_FOUND = 16,
            SWM_RES_OLD_VERSION = 17,
            SWM_RES_INTERNAL_ERROR = 18,
            SWM_RES_GENERAL_ERROR = 19
        };
        
        SWMResult() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SWM_RES_OK)) {}
        SWMResult(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SWM_RES_OK):
                case static_cast<int32_t>(Literal::SWM_RES_ALREADY_PROCESSED):
                case static_cast<int32_t>(Literal::SWM_RES_DEPENDENCY_FAILURE):
                case static_cast<int32_t>(Literal::SWM_RES_VALIDATION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_INSTALL_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_UPGRADE_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_REMOVAL_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_FLASH_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_CREATE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_DELETE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_RESIZE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_WRITE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_PATCH_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_USER_DECLINED):
                case static_cast<int32_t>(Literal::SWM_RES_SOFTWARE_BLACKLISTED):
                case static_cast<int32_t>(Literal::SWM_RES_DISK_FULL):
                case static_cast<int32_t>(Literal::SWM_RES_NOT_FOUND):
                case static_cast<int32_t>(Literal::SWM_RES_OLD_VERSION):
                case static_cast<int32_t>(Literal::SWM_RES_INTERNAL_ERROR):
                case static_cast<int32_t>(Literal::SWM_RES_GENERAL_ERROR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SWMResult &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SWMResult &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SWMResult &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SWMResult &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SWMResult &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SWMResult &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Describes a single element of an installed package.
     */
    struct InstalledPackage : CommonAPI::Struct<std::string, std::string, std::string, uint64_t> {
    	
    	InstalledPackage() {
    	}
    	InstalledPackage(const std::string &_packageId, const std::string &_name, const std::string &_description, const uint64_t &_lastModified)
    	{
    		std::get<0>(values_) = _packageId;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _description;
    		std::get<3>(values_) = _lastModified;
    	}
    	/**
    	 * description: The ID string of the installed package.
    	 */
    	inline const std::string &getPackageId() const { return std::get<0>(values_); }
    	inline void setPackageId(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A symbolic name of the installed package
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: A descriptive text of the installed package
    	 */
    	inline const std::string &getDescription() const { return std::get<2>(values_); }
    	inline void setDescription(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The unix time stamp of when the package was installed
    		or last updated.
    	 */
    	inline const uint64_t &getLastModified() const { return std::get<3>(values_); }
    	inline void setLastModified(const uint64_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const InstalledPackage& _other) const {
                return (getPackageId() == _other.getPackageId() && getName() == _other.getName() && getDescription() == _other.getDescription() && getLastModified() == _other.getLastModified());
        }
    	inline bool operator!=(const InstalledPackage &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Describes a single element of an installed firmware image.
     */
    struct InstalledFirmware : CommonAPI::Struct<std::string, std::string, uint64_t> {
    	
    	InstalledFirmware() {
    	}
    	InstalledFirmware(const std::string &_module, const std::string &_firmwareId, const uint64_t &_lastModified)
    	{
    		std::get<0>(values_) = _module;
    		std::get<1>(values_) = _firmwareId;
    		std::get<2>(values_) = _lastModified;
    	}
    	/**
    	 * description: The name of the module that has firmware installed
    	 */
    	inline const std::string &getModule() const { return std::get<0>(values_); }
    	inline void setModule(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The version id string for the currently installed 
    		firmware.
    	 */
    	inline const std::string &getFirmwareId() const { return std::get<1>(values_); }
    	inline void setFirmwareId(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The unix time stamp of when the module was flashed
    		with the given firmware
    	 *   version
    	 */
    	inline const uint64_t &getLastModified() const { return std::get<2>(values_); }
    	inline void setLastModified(const uint64_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const InstalledFirmware& _other) const {
                return (getModule() == _other.getModule() && getFirmwareId() == _other.getFirmwareId() && getLastModified() == _other.getLastModified());
        }
    	inline bool operator!=(const InstalledFirmware &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* SoftwareLoadingManager::getInterface() {
    return ("org.genivi.SoftwareLoadingManager");
}

CommonAPI::Version SoftwareLoadingManager::getInterfaceVersion() {
    return CommonAPI::Version(1, 0);
}

/**
 * description: Error codes returned as a result of an operation.
 */
/**
 * description: Describes a single element of an installed package.
 */
/**
 * description: Describes a single element of an installed firmware image.
 */

} // namespace genivi
} // namespace org
} // namespace v1

namespace CommonAPI {
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_GENIVI_SOFTWARE_LOADING_MANAGER_HPP_
