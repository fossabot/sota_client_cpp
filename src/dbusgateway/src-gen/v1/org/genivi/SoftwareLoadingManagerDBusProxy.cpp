/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.v201601121430.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: Software Loading Manager interfaace
 */
#include <v1/org/genivi/SoftwareLoadingManagerDBusProxy.hpp>

namespace v1 {
namespace org {
namespace genivi {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createSoftwareLoadingManagerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<SoftwareLoadingManagerDBusProxy>(_address, _connection);
}

INITIALIZER(registerSoftwareLoadingManagerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		SoftwareLoadingManager::getInterface(),
		&createSoftwareLoadingManagerDBusProxy);
}

SoftwareLoadingManagerDBusProxy::SoftwareLoadingManagerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
{
}


    
    /**
     * description: Message, sent by SC or DiagTollMgr to SWLM, to inform that a new
        package is
     *   available for download.
    	This is a fire and forget message. If the update is
     *   to be downloaded,
    	org.genivi.swm.sc.initiate_download() will be called.
     */
    void SoftwareLoadingManagerDBusProxy::updateAvailable(const std::string &_updateId, const std::string &_description, const std::string &_signature, const bool &_requestConfirmation, const uint64_t &_size, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_updateId(_updateId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_description(_description, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_signature(_signature, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_requestConfirmation(_requestConfirmation, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_size(_size, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "updateAvailable",
        "sssbts",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_updateId, deploy_description, deploy_signature, deploy_requestConfirmation, deploy_size, deploy_name,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> SoftwareLoadingManagerDBusProxy::updateAvailableAsync(const std::string &_updateId, const std::string &_description, const std::string &_signature, const bool &_requestConfirmation, const uint64_t &_size, const std::string &_name, UpdateAvailableAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_updateId(_updateId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_description(_description, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_signature(_signature, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_requestConfirmation(_requestConfirmation, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_size(_size, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "updateAvailable",
        "sssbts",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_updateId, deploy_description, deploy_signature, deploy_requestConfirmation, deploy_size, deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Message, sent by SC to SWLM, to indicate
    	that a download previously initiated
     *   by a
     */
    void SoftwareLoadingManagerDBusProxy::downloadComplete(const std::string &_updateImage, const std::string &_signature, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_updateImage(_updateImage, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_signature(_signature, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "downloadComplete",
        "ss",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_updateImage, deploy_signature,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> SoftwareLoadingManagerDBusProxy::downloadCompleteAsync(const std::string &_updateImage, const std::string &_signature, DownloadCompleteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_updateImage(_updateImage, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_signature(_signature, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "downloadComplete",
        "ss",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_updateImage, deploy_signature,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Message, sent by HMI to SWLM to specify
    	if a user confirmed or declined an
     *   update notified to HMI through a
    	org.genivi.swm.hmi.updateNotificataion()
     *   call.
     */
    void SoftwareLoadingManagerDBusProxy::updateConfirmation(const uint32_t &_updateId, const bool &_approved, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_updateId(_updateId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_approved(_approved, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "updateConfirmation",
        "ub",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_updateId, deploy_approved,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> SoftwareLoadingManagerDBusProxy::updateConfirmationAsync(const uint32_t &_updateId, const bool &_approved, UpdateConfirmationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_updateId(_updateId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_approved(_approved, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "updateConfirmation",
        "ub",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_updateId, deploy_approved,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Abort a download in progress.
    	Invoked by HMI in response to SWLM in response
     *   to a user abort.
    	Will be forwarded by SWLM to SC in order to complete the
     *   abort.
     */
    void SoftwareLoadingManagerDBusProxy::abortDownload(const std::string &_updateId, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_updateId(_updateId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "abortDownload",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_updateId,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> SoftwareLoadingManagerDBusProxy::abortDownloadAsync(const std::string &_updateId, AbortDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_updateId(_updateId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "abortDownload",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_updateId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Message, sent by other components to SWLM to report the result
    	of an update
     *   operation initiated by a previous
    	call to one of the following
     *   methods:
    	org.genivi.swm.packmgr.installPackage()
    	org.genivi.swm.packmgr.upgra
     *  dePackage()
    	org.genivi.swm.packmgr.removePackage()
    	org.genivi.swm.partmgr.crea
     *  teDiskPartition()
    	org.genivi.swm.packmgr.deleteDiskPartition()
    	org.genivi.swm.
     *  packmgr.resizeDiskPartition()
    	org.genivi.swm.packmgr.writeDiskPartition()
    	org.
     *  genivi.swm.packmgr.patchDiskPartition()
    	org.genivi.swm.ml.flashModuleFirmware()
     */
    void SoftwareLoadingManagerDBusProxy::operationResult(const uint32_t &_transactionId, const SoftwareLoadingManager::SWMResult &_resultCode, const std::string &_resultText, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_transactionId(_transactionId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<SoftwareLoadingManager::SWMResult, CommonAPI::EmptyDeployment> deploy_resultCode(_resultCode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_resultText(_resultText, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<SoftwareLoadingManager::SWMResult, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "operationResult",
        "uis",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_transactionId, deploy_resultCode, deploy_resultText,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> SoftwareLoadingManagerDBusProxy::operationResultAsync(const uint32_t &_transactionId, const SoftwareLoadingManager::SWMResult &_resultCode, const std::string &_resultText, OperationResultAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_transactionId(_transactionId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<SoftwareLoadingManager::SWMResult, CommonAPI::EmptyDeployment> deploy_resultCode(_resultCode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_resultText(_resultText, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<SoftwareLoadingManager::SWMResult, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "operationResult",
        "uis",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_transactionId, deploy_resultCode, deploy_resultText,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Message, sent by CEDM or SC to SWLM to retrieve a
    	list of installed software
     *   packages and/or module
    	firmware versions.
     */
    void SoftwareLoadingManagerDBusProxy::getInstalledSoftware(const bool &_includePackages, const bool &_includeModuleFirmware, CommonAPI::CallStatus &_internalCallStatus, std::vector<SoftwareLoadingManager::InstalledPackage> &_installedPackages, std::vector<SoftwareLoadingManager::InstalledFirmware> &_installedFirmware, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_includePackages(_includePackages, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_includeModuleFirmware(_includeModuleFirmware, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledPackage>, CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>> deploy_installedPackages(static_cast<CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledFirmware>, CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>> deploy_installedFirmware(static_cast<CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledPackage>,CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>>,
            CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledFirmware>,CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getInstalledSoftware",
        "bb",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_includePackages, deploy_includeModuleFirmware,
_internalCallStatus,
deploy_installedPackages, deploy_installedFirmware);
_installedPackages = deploy_installedPackages.getValue();
_installedFirmware = deploy_installedFirmware.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareLoadingManagerDBusProxy::getInstalledSoftwareAsync(const bool &_includePackages, const bool &_includeModuleFirmware, GetInstalledSoftwareAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_includePackages(_includePackages, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_includeModuleFirmware(_includeModuleFirmware, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledPackage>, CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>> deploy_installedPackages(static_cast<CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledFirmware>, CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>> deploy_installedFirmware(static_cast<CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledPackage>,CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>>,
            CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledFirmware>,CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getInstalledSoftware",
        "bb",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_includePackages, deploy_includeModuleFirmware,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledPackage>, CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledPackageDeployment_t>> _installedPackages, CommonAPI::Deployable<std::vector<SoftwareLoadingManager::InstalledFirmware>, CommonAPI::DBus::ArrayDeployment<SoftwareLoadingManager_::InstalledFirmwareDeployment_t>> _installedFirmware) {
        	if (_callback)
        		_callback(_internalCallStatus, _installedPackages.getValue(), _installedFirmware.getValue());
        },
        std::make_tuple(deploy_installedPackages, deploy_installedFirmware));
    }


void SoftwareLoadingManagerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace genivi
      } // namespace org
      } // namespace v1
